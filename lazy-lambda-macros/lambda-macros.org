#+STARTUP: content showstars indent
#+PROPERTY: header-args:scheme :results value pp :noweb yes

* Idea
I've the idea in my head that macros are just functions that quote
their arguments.  I've never heard them talked about this way before
though.  To test this I'm building a lazily evaluated scheme like
language.
* Back Reference
This is a continuation of the ideas presented in audio logs on 10300.

This is a lazy evaluator of a lisp with both lambda and macros.
* Startup
Just check that everytihng is working first.

#+BEGIN_SRC scheme
  "hello"
#+END_SRC

#+BEGIN_SRC scheme
  (use-modules (system base pmatch))
  (define eval-lazy-lm
   (lambda (expr bindings)
     (pmatch expr
       [,n (guard (number? n)) n]
       [else "error"])))
  (define elm eval-lazy-lm)
#+END_SRC
* 2021-11-13
** First Attempt
I want numbers just so that I can perform some basic calculations and
check that it works.  I'll also need some other base functions to work
with them.  Let's build a basic version without that first, just to
see branching and evaluation order.
#+BEGIN_SRC scheme
  (use-modules (system base pmatch))
  (define elm ;eval-lazy-lambda-macro
   (lambda (expr bindings)
     (pmatch expr
       [,n (guard (number? n)) n]
       [((m ,p ,b) ,a) (elm b (cons `(,p ,a) bindings))]
       [else `(,expr ,bindings)])))
#+END_SRC

Including the old environment from the MiniKanren lectures
#+BEGIN_SRC scheme
  (use-modules (system base pmatch))
  (define empty-env '())
  (define lookup
    (lambda (x env)
      (pmatch env
        [() (error 'lookup
                  (format #t "unbound variable ~s" x))]
        [((,V . ,v) . ,env^) (guard (eq? V x)) v]
        [(,b . ,env^) (lookup x env^)])))
  (define elmr
    (lambda (expr bindings)
      (pmatch expr
              ; numbers
              [,n (guard (number? n)) n]
              ; variable lookup
              [,x (guard (symbol? x)) (elmr (lookup x bindings) bindings)]
              ; lazy macro expansion
              [((m ,p ,b) ,a) (elmr b `((,p ,a) . bindings))]
              ; TODO: lazy lambda expansion
              ; TODO: left left recusion
              ; [(,e ,a) (elmr `(,(elmr e bindings) ,a) bindings)]
              
              ; Can I just wrap the function up into a lazy to make
              ; the recusion single?
              ; [(,e ,a) (let [(t (gensym))]
              ;               (elmr `(,t ,a) `((,t ,e) bindings)))]
              
              ; Not really, because then then next step is to
              ; re-expand it this doesn't remove the double recusion.
              ; Perhaps continuations can save me here.  If I CPS the
              ; interpreter then the second recusion just becomes a
              ; modification of the continuation stack.  I'd prefer to
              ; have the continuation stack shown as a set of bindings
              ; in the lazy evaluation.  Can I do that?  Onto the next
              ; verion!
              
              ; Error case, just show the state
              [else `(,expr ,bindings)])))
  (define elm ;eval-lazy-lambda-macro
    (lambda (expr)
      (elmr expr empty-env)))
#+END_SRC
** CPS Distraction
#+BEGIN_SRC scheme
  (use-modules (system base pmatch))
  (define empty-env '())
  (define lookup
    (lambda (x env)
      (pmatch env
        [() (error 'lookup
                  (format #t "unbound variable ~s" x))]
        [((,V . ,v) . ,env^) (guard (eq? V x)) v]
        [(,b . ,env^) (lookup x env^)])))
  (define elmr
    (lambda (expr cont bindings)
      ; contination is [(fun's binding, local bindings) ... ]
      (pmatch expr
              ; numbers
              [,n (guard (number? n))
                  (elmr `(,(caar cont) ,n) (cdr cont) (cadr cont))]
              ; variable lookup
              [,x (guard (symbol? x))
                  (elmr (lookup x bindings) cont bindings)]
              ; lazy macro expansion
              [((m ,p ,b) ,a)
               (elmr b cont `((,p ,a) . bindings))]
              ; Immediate (non-lazy/symbolic) application
              [((I ,a) ,e)
               (elmr `(,e ,a) cont bindings)]
              ; TODO: lazy lambda expansion
              ; TODO: named aplication
              [(,f ,a) (guard (symbol? f))
               (let ([con (gensym)])
                 (elmr f
                       `((,con ,bindings) . ,cont)
                       `((,con (I ,a)) . ,bindings)))]
                cont bindings];lookup function and continue
              ; TODO: left left recusion
              [(,e ,a)
               (let ([con (gensym)])
                 (elmr e
                       `((,con ,bindings) . ,cont)
                       `((,con (I ,a)) . ,bindings)))]
              ; Error case, just show the state
              [else `(,expr ,cont ,bindings)])))
  (define elm ;eval-lazy-lambda-macro
    (lambda (expr)
      (elmr expr empty-env)))
#+END_SRC

I'm building a new intermediate applicative type to deal twith the
lazy left left, lets's not bother with that for now

Allowing double recursion
** Back to cowboy-ing it
#+BEGIN_SRC scheme
  (use-modules (system base pmatch))
  (define empty-env '())
  (define lookup
    (lambda (x env)
      (pmatch env
        [() (error 'lookup
                  (format #t "unbound variable ~s" x))]
        [((,V . ,v) . ,env^) (guard (eq? V x)) v]
        [(,b . ,env^) (lookup x env^)])))
  (define rep*
    (lambda (old new tree)
      (pmatch tree
              [,s (guard (symbol? s))
                  (if (eq? s old) new s)]
              [() '()]
              [(,a . ,d)
               `(,(rep* old new a) . ,(rep* old new d))])))
  (define elmr
    (lambda (expr bindings)
      (pmatch expr
              ; numbers
              [,n (guard (number? n)) n]
              ; variable lookup
              [,x (guard (symbol? x)) (elmr (lookup x bindings) bindings)]
              ; lazy macro expansion
              [((m ,p ,b) ,a) (elmr b `((,p . ,a) . ,bindings))]
              ; lazy lambda expansion
              [((l ,p ,b) ,a) (let ([s (gensym)])
                                (elmr (rep* p s b)
                                      `((,s . ,a) . ,bindings)))]
              ; left left recusion
              [(,e ,a) (elmr `(,(elmr e bindings) ,a) bindings)]
              ; Error case, just show the state
              [else `(,expr ,bindings)])))
  (define elm ;eval-lazy-lambda-macro
    (lambda (expr)
      (elmr expr empty-env)))
#+END_SRC
*** Some Small tests
#+BEGIN_SRC scheme
(elm '3)
(elm '(m x x))
(elm '((m x x) 3))
#+END_SRC
** Making Let?
let's try and define =let=?  =let= is a new symbol added by a macro
wrapping the environment.  I am building an environment that adds
the macro =let= to the scope.

#+BEGIN_SRC scheme
(l e ((m let e) (m ))
#+END_SRC

=let= has a complex interface with many arguments.  Let's try and do
the factorial test first and then add currying before doing =let=.
** Testing Factorial
From the MiniKanren intro.
#+BEGIN_SRC scheme
(((位 (!) (位 (n) ((! !) n)))
  (位 (!) (位 (n)
           (if (zero? n)
               1
               (* n ((! !) (P n))))))) 5)
#+END_SRC

#+BEGIN_SRC scheme
(((l (!) (l (n) ((! !) n)))
  (l (!) (l (n)
           (if (zero? n)
               1
               (* n ((! !) (P n))))))) 5)
#+END_SRC

I need to add =if=, =p=, and =*= for this to work

#+BEGIN_SRC scheme
  (use-modules (system base pmatch))
  (define empty-env '())
  (define lookup
    (lambda (x env)
      (pmatch env
        [() (error 'lookup
                  (format #t "unbound variable ~s" x))]
        [((,V . ,v) . ,env^) (guard (eq? V x)) v]
        [(,b . ,env^) (lookup x env^)])))
  (define rep*
    (lambda (old new tree)
      (pmatch tree
              [,s (guard (symbol? s))
                  (if (eq? s old) new s)]
              [() '()]
              [(,a . ,d)
               `(,(rep* old new a) . ,(rep* old new d))])))
  (define elmr
    (lambda (expr bindings)
      (pmatch expr
              ; numbers
              [,n (guard (number? n)) n]
              [(P ,n)
               (let ([num (elmr n bindings)])
                 (- num 1))]
              [(* ,a ,b)
               (* (elmr a bindings)
                  (elmr b bindings))]
              [(zero? ,n)
               (zero? (elmr n bindings))]
              ; Temporary Primitives
              [(if ,e ,t ,f)
               (if (elmr e bindings)
                   (elmr t bindings)
                   (elmr f bindings))]
              ; variable lookup
              [,x (guard (symbol? x)) (elmr (lookup x bindings) bindings)]
              ; lazy macro expansion
              [((m ,p ,b) ,a) (elmr b `((,p . ,a) . ,bindings))]
              ; lazy lambda expansion
              [((l ,p ,b) ,a) (let ([s (gensym)])
                                (elmr (rep* p s b)
                                      `((,s . ,a) . ,bindings)))]
              ; left left recusion
              [(,e ,a) (elmr `(,(elmr e bindings) ,a) bindings)]
              ; Error case, just show the state
              [else `(,expr ,bindings)])))
  (define elm ;eval-lazy-lambda-macro
    (lambda (expr)
      (elmr expr empty-env)))
#+END_SRC

#+BEGIN_SRC scheme
(elm '3)
(elm '(m x x))
(elm '((m x x) 3))
(elm '(* 3 2))
(elm '(((l x (l y x)) 3) 2))
(elm '(((l x (l y (* x y))) 3) 2))
#+END_SRC
** An exploration in binding scope
Something is wrong with my bindings or expansion, the last two there
fail.

The binding that x is 3 is being discarded on the =(,e='s rules first
recursive return because I haven't captured the Clojure for =(l y='s
evaluation.  This is why I was going to CPS the interpreter.  I could
still partially do that by just recursively evaluating before
inserting into the bindings?

#+BEGIN_SRC scheme
[(,e ,a) (let ([t (gensym)])
           (elmr `(,t ,a)
                 `((,t ,(elmr e bindings)) . ,bindings)))]
#+END_SRC

Do I need that recursive call?  the symbol lookup already performs the
eval of things inserted.  No; but, I do need to make a rule for =(sym=
distinct from =(expr=.

#+BEGIN_SRC scheme
[(,s ,a) (guard (symbol? s))
 (elmr `(,(elmr s bindings) ,a) bindings)]
[(,e ,a) (let ([t (gensym)])
           (elmr `(,t ,a)
                 `((,t ,e bindings) . ,bindings)))]
#+END_SRC

And this recursion is safe because the symbol lookup can't inject new
bindings that will be discarded?  No, the evaluation of =e= happens
within the lookup call, and that will contain the bindings I need for
its evaluation later.  I need to thread the bindings back out?  Won't
that have extra bindings left in the scope that are provably
unreachable?  Maybe; but, it's safe because of the gensyms.  I sill
don't like it.

Time to thread
** Threading the new scope passing method
I don't need to thread it every where.

I don't think I need to thread back out the bindings introduced within
an evaluation of a primitive, because any bindings they introduce that
weren't deducible from the context don't matter and any that were
still are.
#+BEGIN_SRC scheme
(use-modules (system base pmatch))
(define empty-env '())
(define remeber_as_in
  (lambda (var val env)
    `((,var . ,val) . ,env)))
(define lookup
  (lambda (x env)
    (pmatch env
            [() (error 'lookup
                       (format #t "unbound variable ~s" x))]
            [((,V . ,v) . ,env^) (guard (eq? V x)) v]
            [(,b . ,env^) (lookup x env^)])))
(define rep*
  (lambda (old new tree)
    (pmatch tree
            [,s (guard (not (pair? s)))
                (if (eq? s old) new s)]
            [() '()]
            [(,a . ,d)
             `(,(rep* old new a) . ,(rep* old new d))])))
(define elmr ; expr -> bindings -> (expr bindings)
  (lambda (expr bindings)
    (let ([old_scope (lambda (v) (cons v bindings))]
          [INTERMEDIATE (cons expr bindings)])
      (pmatch expr
              ;; numbers
              [,n (guard (number? n)) (old_scope n)]
              [(P ,n)
               (let ([num (car (elmr n bindings))])
                 (old_scope (- num 1)))]
              [(* ,a ,b)
               (old_scope
                (* (car (elmr a bindings))
                   (car (elmr b bindings))))]
              [(zero? ,n)
               (old_scope
                (zero? (car (elmr n bindings))))]
              ;; Temporary Primitives
              [(if ,c ,t ,f)
               (if (car (elmr c bindings))
                   (elmr t bindings)
                   (elmr f bindings))]
              ;; variable lookup <- Major Un-Lazy-ing Calculation Point
              [,x (guard (symbol? x))
                  (elmr (lookup x bindings) bindings)]
              ;; lazy macro expansion
              [(m ,p ,b) INTERMEDIATE]
              [((m ,p ,b) ,a)
               (let* ([extended_bindings (remeber_as_in p a bindings)])
                 (elmr b extended_bindings))]
              ;; lazy lambda expansion
              [(l ,p ,b) INTERMEDIATE]
              [((l ,p ,b) ,a)
               (let* ([s (gensym)]
                      [body (rep* p s b)]
                      [extended_bindings (remeber_as_in s a bindings)])
                 (elmr body extended_bindings))]
              ;; left left recusion
              [(,s ,a) (guard (symbol? s))
               (let* ([S (elmr s bindings)]
                      [f (car S)]
                      [bind (cdr S)])
                 (elmr `(,f ,a) bind))]
              [(,e ,a) (let* ([t (gensym)]
                              [extended_bindings (remeber_as_in t e bindings)])
                         (elmr `(,t ,a) extended_bindings))]
              ;; Error case, just show the state
              [else `(HALT ,expr ,bindings)]))))
(define elm ;eval-lazy-lambda-macro
  (lambda (expr)
    (let ([V (elmr expr empty-env)])
      (if (eq? 'HALT (car V))
          V
          (car V)))))
#+END_SRC

#+BEGIN_SRC scheme
(elm '3)                                ; 3
(elm '(m x x))                          ; I
(elm '((m x x) 3))                      ; (I 3)
(elm '(* 3 2))                          ; (* 3 2)
(elm '(((l x (l y x)) 3) 2))            ; (#t 3 2)
(elm '(((l x (l y (* x y))) 3) 2))      ; (* 3 2)
#+END_SRC

Got it, I needed to return intermediate values without trying to
evaluate them.  The default case was structuring them without a tag
and they were getting mistakenly re-parsed.

Time for

#+BEGIN_SRC scheme
(((l (!) (l (n) ((! !) n)))
  (l (!) (l (n)
           (if (zero? n)
               1
               (* n ((! !) (P n))))))) 5)
#+END_SRC

Nope

Time to walk the trace.

Woops, forgot that I don't have =()= in my lambdas

#+BEGIN_SRC scheme
(((l ! (l n ((! !) n)))
  (l ! (l n
           (if (zero? n)
               1
               (* n ((! !) (P n))))))) 5)
#+END_SRC

It works!
** Verification of Lazy
Now, let's try and test the lazy.  If I recall the regular Y
combinator isn't resolvable by a normal (non-lazy) interpreter.  Let's
check it in guile and then in mine.

#+BEGIN_SRC scheme
(((l f ((l x (f (x x)))(l x (f (x x)))))
  (l ! (l n (if (zero? n) 1
                (* n (! (P n))))))) 5)
#+END_SRC

Works on mine first try, time to translate/transcribe to regular
lambdas

#+BEGIN_SRC scheme
(define P (lambda n (- n 1)))
(((lambda (f) ((lambda (x) (f (x x)))(lambda (x) (f (x x)))))
  (lambda (!) (lambda (n) (if (zero? n) 1
                              (* n (! (P n))))))) 5)
#+END_SRC

Yee, stack overflow reached.

Now I have to test the macros work.
** Macros?
Is it time for "the man or boy test"?  Nope, it's using =set!= in the
=B= to change the associated =A='s instance of =k=.  A clever test;
but, not one that I support in my functional language.

How to test that macros work?

I guess it's time to implement =let=?  It's a pretty simple extension
to the language.  I don't have cons car cdr yet, so I'm going to have
let be =(let var val body)=.

#+BEGIN_SRC scheme
((l exp (m let exp)
   (
                                        ; defn of let
    (m var (l val (l body
       ((m var body) val))))
    ))
                                        ; code
 (let x 3 x)
 )
#+END_SRC

This requires the second copy of =var= to be replaced by a lookup of
the first copy of =var=.  Lookup must return the binding scope that
the binding was made in so that if there are successive lookups, they
can happen at the correct scope?  Then any bindings added in the sub
scope will need to be added to the calling scope as well though.
Right, this is what hygienic macros are for; but, I intentionally
didn't use those because they can be implemented using regular macros
and lambdas.  So, is this correct?  I think so, the body will look up
=let=, it'll find that it's been ... No, =var= has been bound to it,
not the other way around.  This is what quoting is for.  If I make it
so that macros evaluate their formal parameter I can quote the
instances where I mean it as an atom and let it be dereference when I
mean its value.  Can I do the same with lambdas?  Sure, there's no
reason that I can't, it'll just look a little strange to normal
lisp/scheme.

#+BEGIN_SRC scheme
(use-modules (system base pmatch))
(define empty-env '())
(define remeber_as_in
  (lambda (var val env)
    `((,var . ,val) . ,env)))
(define lookup
  (lambda (x env)
    (pmatch env
            [() (error 'lookup
                       (format #t "unbound variable ~s" x))]
            [((,V . ,v) . ,env^) (guard (eq? V x)) v]
            [(,b . ,env^) (lookup x env^)])))
(define rep*
  (lambda (old new tree)
    (pmatch tree
            [,s (guard (not (pair? s)))
                (if (eq? s old) new s)]
            [() '()]
            [(,a . ,d)
             `(,(rep* old new a) . ,(rep* old new d))])))
(define elmr ; expr -> bindings -> (expr bindings)
  (lambda (expr bindings)
    (let ([old_scope (lambda (v) (cons v bindings))]
          [INTERMEDIATE (cons expr bindings)])
      (pmatch expr
              ;; numbers
              [,n (guard (number? n)) (old_scope n)]
              [(P ,n)
               (let ([num (car (elmr n bindings))])
                 (old_scope (- num 1)))]
              [(* ,a ,b)
               (old_scope
                (* (car (elmr a bindings))
                   (car (elmr b bindings))))]
              [(zero? ,n)
               (old_scope
                (zero? (car (elmr n bindings))))]
              ;; Temporary Primitives
              [(if ,c ,t ,f)
               (if (car (elmr c bindings))
                   (elmr t bindings)
                   (elmr f bindings))]
              ;; variable lookup <- Major Un-Lazy-ing Calculation Point
              [(q ,x) (old_scope x)]
              [,x (guard (symbol? x))
                  (elmr (lookup x bindings) bindings)]
              ;; lazy macro expansion
              [(m ,p ,b) INTERMEDIATE]
              [((m ,p ,b) ,a)
               (let* ([param (car (elmr p bindings))]
                      [extended_bindings (remeber_as_in param a bindings)])
                 (elmr b extended_bindings))]
              ;; lazy lambda expansion
              [(l ,p ,b) INTERMEDIATE]
              [((l ,p ,b) ,a)
               (let* ([s (gensym)]
                      [param (car (elmr p bindings))]
                      [body (rep* param s b)]
                      [extended_bindings (remeber_as_in s a bindings)])
                 (elmr body extended_bindings))]
              ;; left left recusion
              [(,s ,a) (guard (symbol? s))
               (let* ([S (elmr s bindings)]
                      [f (car S)]
                      [bind (cdr S)])
                 (elmr `(,f ,a) bind))]
              [(,e ,a) (let* ([t (gensym)]
                              [extended_bindings (remeber_as_in t e bindings)])
                         (elmr `(,t ,a) extended_bindings))]
              ;; Error case, just show the state
              [else `(HALT ,expr ,bindings)]))))
(define elm ;eval-lazy-lambda-macro
  (lambda (expr)
    (let ([V (elmr expr empty-env)])
      (if (eq? 'HALT (car V))
          V
          (car V)))))
#+END_SRC

It seems that I can't pattern match against the =quote= because it's
parsed within the =pmatch= pattern.  Using =q= for now as an easy
workaround.

#+BEGIN_SRC scheme
(elm '3)                                    ; 3
(elm '(m (q x) x))                          ; I
(elm '((m (q x) x) 3))                      ; (I 3)
(elm '(* 3 2))                              ; (* 3 2)
(elm '(((l (q x) (l (q y) x)) 3) 2))        ; (#t 3 2)
(elm '(((l (q x) (l (q y) (* x y))) 3) 2))  ; (* 3 2)
#+END_SRC


#+BEGIN_SRC scheme
((l (q exp) ((m (q let) exp)
                                        ; defn of let
    (m (q var) (l (q val) (l (q body)
       ((m var body) val))))
    ))
                                        ; code
 (((let (q x)) 3) x)
 )
#+END_SRC

Yeeeee
* 2021-11-14
** Pulling out needless things
Let's throw out everythign that isn't needed and check that it still works.
#+BEGIN_SRC scheme
(use-modules (system base pmatch))
(define lookup
  (lambda (x env)
    (pmatch env
            [() (error 'lookup
                       (format #t "unbound variable ~s" x))]
            [((,V . ,v) . ,env^) (guard (eq? V x)) v]
            [(,b . ,env^) (lookup x env^)])))
(define rep*
  (lambda (old new tree)
    (pmatch tree
            [,s (guard (not (pair? s)))
                (if (eq? s old) new s)]
            [() '()]
            [(,a . ,d)
             `(,(rep* old new a) . ,(rep* old new d))])))
(define elmr ; expr -> bindings -> (expr bindings)
  (lambda (expr bindings)
    (let ([old_scope (lambda (v) (cons v bindings))]
          [INTERMEDIATE (cons expr bindings)])
      (pmatch expr
              ;; variable lookup <- Major Un-Lazy-ing Calculation Point
              [(q ,x) (old_scope x)]
              [,x (guard (symbol? x))
                  (elmr (lookup x bindings) bindings)]
              ;; lazy macro expansion
              [(m ,p ,b) INTERMEDIATE]
              [((m ,p ,b) ,a)
               (let* ([param (car (elmr p bindings))]
                      [extended_bindings `((,param ,a) . ,bindings)])
                 (elmr b extended_bindings))]
              ;; lazy lambda expansion
              [(l ,p ,b) INTERMEDIATE]
              [((l ,p ,b) ,a)
               (let* ([s (gensym)]
                      [param (car (elmr p bindings))]
                      [body (rep* param s b)]
                      [extended_bindings `((,s ,a) . ,bindings)])
                 (elmr body extended_bindings))]
              ;; left left recusion
              [(,s ,a) (guard (symbol? s))
               (let* ([S (elmr s bindings)]
                      [f (car S)]
                      [bind (cdr S)])
                 (elmr `(,f ,a) bind))]
              [(,e ,a) (let* ([t (gensym)]
                              [extended_bindings `((,t ,e) . ,bindings)])
                         (elmr `(,t ,a) extended_bindings))]
              ;; Error case, just show the state
              [else `(HALT ,expr ,bindings)]))))
(define elm ;eval-lazy-lambda-macro
  (lambda (expr)
    (let ([V (elmr expr '())])
      (if (eq? 'HALT (car V))
          V
          (car V)))))
#+END_SRC

That's not as small as I hoped.  I'll have to switch to a lambda
abstraction for bindings to remove the =lookup= function.

#+BEGIN_SRC scheme
(use-modules (system base pmatch))
(define rep*
  (lambda (old new tree)
    (pmatch tree
            [,s (guard (not (pair? s)))
                (if (eq? s old) new s)]
            [() '()]
            [(,a . ,d)
             `(,(rep* old new a) . ,(rep* old new d))])))
(define elmr ; expr -> bindings -> (expr bindings)
  (lambda (expr bindings)
    (let ([old_scope (lambda (v) (cons v bindings))]
          [INTERMEDIATE (cons expr bindings)])
      (pmatch expr
              ;; variable lookup <- Major Un-Lazy-ing Calculation Point
              [(q ,x) (old_scope x)]
              [,x (guard (symbol? x))
                  (elmr (bindings x) bindings)]
              ;; lazy macro expansion
              [(m ,p ,b) INTERMEDIATE]
              [((m ,p ,b) ,a)
               (let* ([param (car (elmr p bindings))]
                      [extended_bindings (lambda (v) (if (eq? v a) param (bindings v)))])
                 (elmr b extended_bindings))]
              ;; lazy lambda expansion
              [(l ,p ,b) INTERMEDIATE]
              [((l ,p ,b) ,a)
               (let* ([s (gensym)]
                      [param (car (elmr p bindings))]
                      [body (rep* param s b)]
                      [extended_bindings (lambda (v) (if (eq? v a) s (bindings v)))])
                 (elmr body extended_bindings))]
              ;; left left recusion
              [(,s ,a) (guard (symbol? s))
               (let* ([S (elmr s bindings)]
                      [f (car S)]
                      [bind (cdr S)])
                 (elmr `(,f ,a) bind))]
              [(,e ,a) (let* ([t (gensym)]
                              [extended_bindings (lambda (v) (if (eq? v e) t (bindings v)))])
                         (elmr `(,t ,a) extended_bindings))]
              ;; Error case, just show the state
              [else `(HALT ,expr ,bindings)]))))
(define elm
  (lambda (expr)
    (elmr expr (lambda (v) `(ERR ,v)))))
#+END_SRC

Time to take out the lets.

#+BEGIN_SRC scheme
(use-modules (system base pmatch))
(define rep*
  (lambda (old new tree)
    (pmatch tree
            [,s (guard (not (pair? s)))
                (if (eq? s old) new s)]
            [() '()]
            [(,a . ,d)
             `(,(rep* old new a) . ,(rep* old new d))])))
(define elmr ; expr -> bindings -> (expr bindings)
  (lambda (expr bindings)
    (let ([old_scope (lambda (v) (cons v bindings))]
          [INTERMEDIATE (cons expr bindings)])
      (pmatch expr
              ;; variable lookup <- Major Un-Lazy-ing Calculation Point
              [(q ,x) (old_scope x)]
              [,x (guard (symbol? x))
                  (elmr (bindings x) bindings)]
              ;; lazy macro expansion
              [(m ,p ,b) INTERMEDIATE]
              [((m ,p ,b) ,a)
                 (elmr b (lambda (v) (if (eq? v a) (car (elmr p bindings)) (bindings v))))]
              ;; lazy lambda expansion
              [(l ,p ,b) INTERMEDIATE]
              [((l ,p ,b) ,a)
               (let ([s (gensym)])
                 (elmr (rep* (car (elmr p bindings)) s b)
                       (lambda (v) (if (eq? v a) s (bindings v)))))]
              ;; left left recusion
              [(,s ,a) (guard (symbol? s))
               (let ([S (elmr s bindings)])
                 (elmr `(,(car S) ,a) (cdr S)))]
              [(,e ,a) (let* ([t (gensym)])
                         (elmr `(,t ,a)
                               (lambda (v) (if (eq? v e) t (bindings v)))))]
              ;; Error case, just show the state
              [else `(HALT ,expr ,bindings)]))))
(define elm
  (lambda (expr)
    (elmr expr (lambda (v) `(ERR ,v)))))
#+END_SRC

And the error handling

#+BEGIN_SRC scheme
(use-modules (system base pmatch))
(define alpha
  (lambda (old new tree)
    (pmatch tree
            [(,a . ,d) (cons (alpha old new a) 
                             (alpha old new d))]
            [() '()]
            [,sym (if (eq? sym old) new sym)])))
(define elmr
  (lambda (expr bindings)
    (pmatch expr
            ;; variable lookup
            [,x (guard (symbol? x))
                (elmr (bindings x) bindings)]
            ;; quote pass though
            [(q ,x) (cons x bindings)]
            ;; macro application
            [((m ,p ,b) ,a)
             (elmr b (lambda (v) (if (eq? v a) (car (elmr p bindings)) (bindings v))))]
            ;; lambda expansion
            [((l ,p ,b) ,a)
             (let ([s (gensym)])
               (elmr (alpha (car (elmr p bindings)) s b)
                     (lambda (v) (if (eq? v a) s (bindings v)))))]
            ;; variable application
            [(,s ,a) (guard (symbol? s))
             (let ([S (elmr s bindings)])
               (elmr `(,(car S) ,a) (cdr S)))]
            ;; lazy expression application
            [(,e ,a) (guard (pair? e ))
             (let ([t (gensym)])
               (elmr `(,t ,a)
                     (lambda (v) (if (eq? v e) t (bindings v)))))]
            ;; self evaluation
            [else (cons expr bindings)])))
(define elm
  (lambda (expr)
    (elmr expr (lambda (v) `(ERR ,v)))))
#+END_SRC

Hehe, I don't need to guard against the =,s= matching ='l= or ='m=
because they are the only way of taking two arguments.  I'll loose
that if I add currying; but, for the simple version, that's not
needed.
* 2021-11-15 Removed lambda expansion for macro substitution
If lambdas are just macros with alpha renaming, those can be separate
steps.

Here that is as a full implementation

#+BEGIN_SRC scheme
(use-modules (system base pmatch))
(define empty-env '())
(define remember_as_in
  (lambda (var val env)
    `((,var . ,val) . ,env)))
(define lookup
  (lambda (x env)
    (pmatch env
            [() (error 'lookup
                       (format #t "unbound variable ~s" x))]
            [((,V . ,v) . ,env^) (guard (eq? V x)) v]
            [(,b . ,env^) (lookup x env^)])))
(define rep*
  (lambda (old new tree)
    (pmatch tree
            [,s (guard (not (pair? s)))
                (if (eq? s old) new s)]
            [() '()]
            [(,a . ,d)
             `(,(rep* old new a) . ,(rep* old new d))])))
(define elmr ; expr -> bindings -> (expr bindings)
  (lambda (expr bindings)
    (let ([old_scope (lambda (v) (cons v bindings))]
          [INTERMEDIATE (cons expr bindings)])
      (pmatch expr
              ;; numbers
              [,n (guard (number? n)) INTERMEDIATE]
              [(P ,n)
               (let ([num (car (elmr n bindings))])
                 (old_scope (- num 1)))]
              [(* ,a ,b)
               (old_scope
                (* (car (elmr a bindings))
                   (car (elmr b bindings))))]
              [(zero? ,n)
               (old_scope
                (zero? (car (elmr n bindings))))]
              ;; Temporary Primitives
              [(if ,c ,t ,f)
               (if (car (elmr c bindings))
                   (elmr t bindings)
                   (elmr f bindings))]
              ;; Quote
              [(q ,x) (old_scope x)]
              ;; variable lookup <- Major Un-Lazy-ing Calculation Point
              [,x (guard (symbol? x))
                  (elmr (lookup x bindings) bindings)]
              ;; lazy macro expansion
              [(m ,p ,b) INTERMEDIATE]
              [((m ,p ,b) ,a)
               (let* ([param (car (elmr p bindings))]
                      [extended_bindings (remember_as_in param a bindings)])
                 (elmr b extended_bindings))]
              ;; lazy lambda expansion
              ;; Alpha rename to a gensym, then be a macro.
              [(l ,p ,b)
               (let* ([s (gensym)]
                      [p^ (car (elmr p bindings))]
                      [b^ (rep* p^ s b)])
                 (old_scope `(m (q ,s) ,b^)))]
              ;; left left recursion
              [(,s ,a) (guard (symbol? s))
               (let* ([S (elmr s bindings)]
                      [f (car S)]
                      [bind (cdr S)])
                 (elmr `(,f ,a) bind))]
              [(,e ,a) (let* ([t (gensym)]
                              [extended_bindings (remember_as_in t e bindings)])
                         (elmr `(,t ,a) extended_bindings))]
              ;; Error case, just show the state
              [else `(HALT ,expr ,bindings)]))))
(define elm ;eval-lazy-lambda-macro
  (lambda (expr)
    (let ([V (elmr expr empty-env)])
      (if (eq? 'HALT (car V))
          V
          (car V)))))
#+END_SRC

And here's the reduced to only needed bits one.

#+BEGIN_SRC scheme
(use-modules (system base pmatch))
(define alpha
  (lambda (old new tree)
    (pmatch tree
            [(,a . ,d) (cons (alpha old new a) 
                             (alpha old new d))]
            [() '()]
            [,sym (if (eq? sym old) new sym)])))
(define elmr
  (lambda (expr bindings)
    (pmatch expr
            ;; variable lookup
            [,x (guard (symbol? x))
                (elmr (bindings x) bindings)]
            ;; quote pass though
            [(q ,x) (cons x bindings)]
            ;; macro application
            [((m ,p ,b) ,a)
             (elmr b (lambda (v) (if (eq? v a) (car (elmr p bindings)) (bindings v))))]
            ;; lambdas alpha-rename to macros
            [(l ,p ,b)
             (let ([s (gensym)])
               (cons `(m (q ,s) ,(alpha (car (elmr p bindings)) s b))
                     (bindings v)))]
            ;; variable application
            [(,s ,a) (guard (symbol? s))
             (let ([S (elmr s bindings)])
               (elmr `(,(car S) ,a) (cdr S)))]
            ;; lazy expression application
            [(,e ,a) (guard (pair? e ))
             (let ([t (gensym)])
               (elmr `(,t ,a)
                     (lambda (v) (if (eq? v e) t (bindings v)))))]
            ;; self evaluation
            [else (cons expr bindings)])))
(define elm
  (lambda (expr)
    (elmr expr (lambda (v) `(ERR ,v)))))
#+END_SRC

Now only macros can self evaluate, removing the else.

#+BEGIN_SRC scheme
(use-modules (system base pmatch))
(define alpha
  (lambda (old new tree)
    (pmatch tree
            [(,a . ,d) (cons (alpha old new a) 
                             (alpha old new d))]
            [() '()]
            [,sym (if (eq? sym old) new sym)])))
(define elmr
  (lambda (expr bindings)
    (pmatch expr
            ;; variable lookup
            [,x (guard (symbol? x))
                (elmr (bindings x) bindings)]
            ;; quote pass though
            [(q ,x) (cons x bindings)]
            ;; macros are self evaluating
            [(m ,p ,b) (cons expr bindings)]
            ;; macro application
            [((m ,p ,b) ,a)
             (elmr b (lambda (v) (if (eq? v a) (car (elmr p bindings)) (bindings v))))]
            ;; lambdas alpha-rename to macros
            [(l ,p ,b)
             (let ([s (gensym)])
               (cons `(m (q ,s) ,(alpha (car (elmr p bindings)) s b))
                     (bindings v)))]
            ;; variable application
            [(,s ,a) (guard (symbol? s))
             (let ([S (elmr s bindings)])
               (elmr `(,(car S) ,a) (cdr S)))]
            ;; lazy expression application
            [(,e ,a) (guard (pair? e ))
             (let ([t (gensym)])
               (elmr `(,t ,a)
                     (lambda (v) (if (eq? v e) t (bindings v)))))])))
(define elm
  (lambda (expr)
    (elmr expr (lambda (v) `(ERR ,v)))))
#+END_SRC

Could I make =alpha= the primitive and have lambda just expand?

#+BEGIN_SRC scheme
(use-modules (system base pmatch))
(define empty-env '())
(define remember_as_in
  (lambda (var val env)
    `((,var . ,val) . ,env)))
(define lookup
  (lambda (x env)
    (pmatch env
            [() (error 'lookup
                       (format #t "unbound variable ~s" x))]
            [((,V . ,v) . ,env^) (guard (eq? V x)) v]
            [(,b . ,env^) (lookup x env^)])))
(define alpha
  (lambda (old new tree)
    (pmatch tree
            [,s (guard (not (pair? s)))
                (if (eq? s old) new s)]
            [() '()]
            [(,a . ,d)
             `(,(alpha old new a) . ,(alpha old new d))])))
(define elmr ; expr -> bindings -> (expr bindings)
  (lambda (expr bindings)
    (let ([old_scope (lambda (v) (cons v bindings))]
          [INTERMEDIATE (cons expr bindings)])
      (pmatch expr
              ;; numbers
              [,n (guard (number? n)) INTERMEDIATE]
              [(P ,n)
               (let ([num (car (elmr n bindings))])
                 (old_scope (- num 1)))]
              [(* ,a ,b)
               (old_scope
                (* (car (elmr a bindings))
                   (car (elmr b bindings))))]
              [(zero? ,n)
               (old_scope
                (zero? (car (elmr n bindings))))]
              ;; Temporary Primitives
              [(if ,c ,t ,f)
               (if (car (elmr c bindings))
                   (elmr t bindings)
                   (elmr f bindings))]
              ;; Quote
              [(q ,x) (old_scope x)]
              ;; variable lookup <- Major Un-Lazy-ing Calculation Point
              [,x (guard (symbol? x))
                  (elmr (lookup x bindings) bindings)]
              ;; Macro Binding
              [(m ,p ,b) INTERMEDIATE]
              [((m ,p ,b) ,a)
               (let* ([param (car (elmr p bindings))]
                      [extended_bindings (remember_as_in param a bindings)])
                 (elmr b extended_bindings))]
              ;; Lambda Expansion
              ;; Alpha Rename to a gensym, then be a macro.
              [(l ,p ,b)
               (let ([s (gensym)])
                 (old_scope
                  `(a ,p (q ,s) (m ,s ,b))))]
              ;; Alpha Renaming
              ;; I know that ,n will be a quote because I generated it; but, generality
              [(a ,o ,n ,b)
               (let ([o^ (car (elmr o bindings))]
                     [n^ (car (elmr n bindings))])
                 (old_scope (alpha o^ n^ b)))]
              ;; left left recursion
              [(,s ,a) (guard (symbol? s))
               (let* ([S (elmr s bindings)]
                      [f (car S)]
                      [bind (cdr S)])
                 (elmr `(,f ,a) bind))]
              [(,e ,a) (let* ([t (gensym)]
                              [extended_bindings (remember_as_in t e bindings)])
                         (elmr `(,t ,a) extended_bindings))]
              ;; Error case, just show the state
              [else `(HALT ,expr ,bindings)]))))
(define elm ;eval-lazy-lambda-macro
  (lambda (expr)
    (let ([V (elmr expr empty-env)])
      (if (eq? 'HALT (car V))
          V
          (car V)))))
#+END_SRC

Hmm, if I move the alpha renaming function to be inline, then this can
deal with infinite code trees as well.  This won't matter for user
entered code, but, if MiniKanren is generating holes, this will
prevent unnecessary expansion.

#+BEGIN_SRC scheme
(use-modules (system base pmatch))
(define empty-env '())
(define remember_as_in
  (lambda (var val env)
    `((,var . ,val) . ,env)))
(define lookup
  (lambda (x env)
    (pmatch env
            [() (error 'lookup
                       (format #t "unbound variable ~s" x))]
            [((,V . ,v) . ,env^) (guard (eq? V x)) v]
            [(,b . ,env^) (lookup x env^)])))
(define alpha
  (lambda (old new tree)
    (pmatch tree
            [,s (guard (not (pair? s)))
                (if (eq? s old) new s)]
            [() '()]
            [(,a . ,d)
             `(,(alpha old new a) . ,(alpha old new d))])))
(define elmr ; expr -> bindings -> (expr bindings)
  (lambda (expr bindings)
    (let ([old_scope (lambda (v) (cons v bindings))]
          [INTERMEDIATE (cons expr bindings)])
      (pmatch expr
              ;; numbers
              [,n (guard (number? n)) INTERMEDIATE]
              [(P ,n)
               (let ([num (car (elmr n bindings))])
                 (old_scope (- num 1)))]
              [(* ,a ,b)
               (old_scope
                (* (car (elmr a bindings))
                   (car (elmr b bindings))))]
              [(zero? ,n)
               (old_scope
                (zero? (car (elmr n bindings))))]
              ;; Temporary Primitives
              [(if ,c ,t ,f)
               (if (car (elmr c bindings))
                   (elmr t bindings)
                   (elmr f bindings))]
              ;; Quote
              [(q ,x) (old_scope x)]
              ;; variable lookup <- Major Un-Lazy-ing Calculation Point
              [,x (guard (symbol? x))
                  (elmr (lookup x bindings) bindings)]
              ;; Macro Binding
              [(m ,p ,b) INTERMEDIATE]
              [((m ,p ,b) ,a)
               (let* ([param (car (elmr p bindings))]
                      [extended_bindings (remember_as_in param a bindings)])
                 (elmr b extended_bindings))]
              ;; Lambda Expansion
              ;; Alpha Rename to a gensym, then be a macro.
              [(l ,p ,b)
               (let ([s (gensym)])
                 (old_scope
                  `(a ,p (q ,s) (m ,s ,b))))]
              ;; Alpha Renaming
              ;; pair
              [(a ,o ,n (,ba . ,bd))
               (old_scope `((a ,o ,n ,ba) ]
              ;; empty
              ;; symbol
              ;; default
              [(a ,o ,n ,b)
               (let ([o^ (car (elmr o bindings))]
                     [n^ (car (elmr n bindings))])
                 (old_scope (alpha o^ n^ b)))]
              ;; left left recursion
              [(,s ,a) (guard (symbol? s))
               (let* ([S (elmr s bindings)]
                      [f (car S)]
                      [bind (cdr S)])
                 (elmr `(,f ,a) bind))]
              [(,e ,a) (let* ([t (gensym)]
                              [extended_bindings (remember_as_in t e bindings)])
                         (elmr `(,t ,a) extended_bindings))]
              ;; Error case, just show the state
              [else `(HALT ,expr ,bindings)]))))
(define elm ;eval-lazy-lambda-macro
  (lambda (expr)
    (let ([V (elmr expr empty-env)])
      (if (eq? 'HALT (car V))
          V
          (car V)))))
#+END_SRC

I need to add cons to the language for that?  I could make Lambdas,
Macros, and Alphas Curried?  That'll be ugly.  Let's try it.


#+BEGIN_SRC scheme
(use-modules (ice-9 pretty-print))
(use-modules (system base pmatch))
(define dots (lambda (v)
               (display ".")
               (if (null? v) '()
                   (dots (cdr v)))))
;(define prnt
;  (lambda (v) (dots v) (display "\n")))
(define prnt
  (lambda (v) (write v) (display "\n")))
(define empty-env '())
(define remember_as_in
  (lambda (var val env)
    `((,var . ,val) . ,env)))
(define lookup
  (lambda (x env explanation)
    (pmatch env
            [() (error 'lookup
                       (format #t "unbound variable ~s" x))]
            [((,V . ,v) . ,env^)
             (guard (eq? V x))
             (prnt `((lookup ,x) . ,explanation))
             v]
            [(,b . ,env^) (lookup x env^ explanation)])))
(define gcar ; guard car
  (lambda (p)
    (if (pair? p) (car p) #f)))
(define elmr ; expr -> bindings -> (expr bindings)
  (lambda (expr bindings explanation)
    (prnt explanation)
    (prnt `(expr ,expr))
    (prnt `(bind ,bindings))
    (pretty-print `(bind ,bindings))
    (prnt '())
    (let ([old_scope (lambda (v) (cons v bindings))]
          [INTERMEDIATE (cons expr bindings)])
      (pmatch expr
              ;; numbers
              [,n (guard (number? n)) INTERMEDIATE]
              [(P ,n)
               (let ([num (car (elmr n bindings (cons 'P explanation)))])
                 (old_scope (- num 1)))]
              [(* ,a) INTERMEDIATE]
              [((* ,a) ,b)
               (old_scope
                (* (car (elmr a bindings (cons '*l explanation)))
                   (car (elmr b bindings (cons '*r explanation)))))]
              [(zero? ,n)
               (old_scope
                (zero? (car (elmr n bindings (cons 'zero? explanation)))))]
              ;; Temporary Primitives
              [if INTERMEDIATE]
              [(if ,c) INTERMEDIATE]
              [((if ,c) ,t) INTERMEDIATE]
              [(((if ,c) ,t) ,f)
               (if (car (elmr c bindings (cons 'if explanation)))
                   (elmr t bindings explanation)
                   (elmr f bindings explanation))]
              ;; Quote
              [q INTERMEDIATE]
              [(q ,x) (old_scope x)]
              ;; Macro Binding
              [m INTERMEDIATE]
              [(m ,p) INTERMEDIATE]
              [((m ,p) ,b) INTERMEDIATE]
              [(((m ,p) ,b) ,a)
               (let* ([p^ (car (elmr p bindings (cons 'm-bind explanation)))]
                      [extended_bindings (remember_as_in p^ a bindings)])
                 (elmr b extended_bindings explanation))]
              ;; Lambda Expansion
              ;; Alpha Rename to a gensym, then be a macro.
              [l INTERMEDIATE]
              [(l ,p) INTERMEDIATE]
              [((l ,p) ,b)
               (let ([s (gensym)])
                 (old_scope
                  `((m (q ,s)) (((a ,p) (q ,s)) ,b))))]
              ;; Alpha Renaming
              [a INTERMEDIATE]
              [(a ,o) INTERMEDIATE]
              [((a ,o) ,n) INTERMEDIATE]
              ;; Double Alpha - resolve inner
              [(((a ,o) ,n) ,b)
               (guard (eq? (gcar (gcar (gcar b))) 'a))
               (let* ([S (elmr b bindings (cons 'aa explanation))]
                     [bod (car S)]
                     [bind (cdr S)])
                 (elmr `(((a ,o) ,n) ,bod)
                       bind explanation))]
              ;; Alpha(Pair)
              [(((a ,o) ,n) (,ba ,bd))
               ;(guard (not (eq? bd 'a))) 
               (elmr `((((a ,o) ,n) ,ba)
                       (((a ,o) ,n) ,bd))
                     bindings explanation)]
              ;; Alpha(Symbol)
              [(((a ,o) ,n) ,s) (guard (symbol? s))
               (let ([o^ (car (elmr o bindings (cons 'alpha-o explanation)))]
                     [n^ (car (elmr n bindings (cons 'alpha-n explanation)))])
                 (elmr (if (eq? o^ s) n^ s)
                       bindings explanation))]
              ;; left left recursion
              [(,s ,a) (guard (symbol? s))
               (let* ([S (elmr s bindings (cons `(left ,a) explanation))]
                      [f (car S)]
                      [bind (cdr S)])
                 (elmr `(,f ,a) bind explanation))]
              [(,e ,a) (let* ([t (gensym)]
                              [extended_bindings (remember_as_in t e bindings)])
                         (elmr `(,t ,a) extended_bindings explanation))]
              ;; Variable Lookup (& Lazy's Undeferring)
              [,x (guard (symbol? x))
                  (elmr (lookup x bindings explanation) bindings explanation)]
              ;; Error case, just show the state
              [else `(HALT ,expr ,bindings)]))))
(define elm ;eval-lazy-lambda-macro
  (lambda (expr)
    (let ([V (elmr expr empty-env '(eval))])
      (if (eq? 'HALT (car V))
          V
          (car V)))))
#+END_SRC

Now I really need to retest this.

#+BEGIN_SRC scheme
;; Simple Tests
(elm '3)                                        ; 3
(elm '((m (q x)) x))                            ; I
(elm '((l (q x)) x))                            ; I
(elm '(((m (q x)) x) 3))                        ; (I 3)
(elm '(((l (q x)) x) 3))                        ; (I 3)
(elm '((* 3) 2))                                ; (* 3 2)
(elm '(((l (q x)) ((l (q y)) x)) 3))            ; (#t 3)
(elm '((((l (q x)) ((l (q y)) x)) 3) 2))        ; (#t 3 2)
(elm '((((l (q x)) ((l (q y)) (* x y))) 3) 2))  ; (* 3 2)

;; Regular Factorial
(elm '((((l !) ((l n) ((! !) n)))
        ((l !) ((l n)
                (((if (zero? n))
                  1)
                 ((* n) ((! !) (P n))))))) 5))

;; Lazy Dependent Factorial
(elm '((((l f) (((l x) (f (x x)))((l x) (f (x x)))))
        ((l !) ((l n) (((if (zero? n)) 1)
                       ((* n) (! (P n))))))) 5))

;; Defining =let=
(elm '(((l (q exp))
        ;; Defn of =let=
        (((m (q let)) exp)
         ((m (q var)) ((l (q val)) ((l (q body))
                                    (((m var) body) val))))
         ))
       ;; Code in new Evaluator
       (((let (q x)) 3) x)))
#+END_SRC
